## Паттерн "посетитель" (visitor, практика 15-210128), сравнение с толпой dynamic_cast или добавлением виртуальных функций в базовый класс.

[https://github.com/egorSheremetov02/cpp-exam-summer-2021/blob/master/Наследование_и_классы.md#паттерн-посетитель-visitor-практика-15-210128-сравнение-с-dynamic_cast-или-добавление-виртуальных-функций-в-базовый-класс](https://github.com/egorSheremetov02/cpp-exam-summer-2021/blob/master/%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B8_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md#%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD-%D0%BF%D0%BE%D1%81%D0%B5%D1%82%D0%B8%D1%82%D0%B5%D0%BB%D1%8C-visitor-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0-15-210128-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81-dynamic_cast-%D0%B8%D0%BB%D0%B8-%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9-%D0%B2-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B9-%D0%BA%D0%BB%D0%B0%D1%81%D1%81)

Visitor подходит лучше виртуальных функций, когда выполнены условия

1. Иерархия почти фиксирована.
2. Могут активно добавляться новые функции.

Либо мы не можем добавлять новые виртуальные функции (пишем плагин IDE, а IDE представляет иерархию классов). Мы не можем добавить туда виртуальную функцию, зато можем реализовать Visitor (если IDE сделала метод accept, конечно).

Рассмотрим `print_to()` из `Employee` . Может быть много форматов вывода ⇒ нужно будет реализовать много виртуальных функций (всем нужно придумать имя, они все лежат в одном классе и все пользователи этого класса могут ими пользоваться, а мы этого не хотим). 

Виртуальные функции имеют доступ к приватным и защищенным полям. Если у нас есть большой проект, то иерархия классов от добавления функций будет разрастаться и нужно будет перекомпилировать проект каждый раз.

Можно кастовать к наследнику и вызывать перегрузку, но выглядит длинно

```cpp
inline std::ostream &operator<<(std::ostream &os, const Employee &e) {
		if (const Developer *d = dynamic_cast<const Developer*>(&e); d) { //if-init statement
		    // d->operator<<(os);  // d << os
		    os << *d;
		} else if (const SalesManager *sm = dynamic_cast<const SalesManager*>(&e); sm) {
		    os << *sm;
		} else {
		    assert(false);
}
```

Давайте вместо этого сделаем свою структуру

```cpp
struct EmployeeVisitor{
    virtual void visit(const Developer &d) = 0;
}

struct Employee{
    ...
    virtual void accept(EmployeeVisitor &d) = 0;
}

struct SalesManager : Employee {
    ...
    virtual void accept(EmployeeVisitor &v) const override {
        v.visit(*this);
    }
}
// переопределяем accept() у наследников
```

Теперь не надо писать много if-ов и `dynamic_cast` , делаем одну функцию `accept` 

Добавим новую функцию: создаем себе EmployeeVisitor, определяем как работает функция visit у наследников, вызываем метод accept, это виртуальная функция, которая в подходящем классе вызовет visit

```cpp
inline std::ostream &operator<<(std::ostream &os, const Employee &e) {
		struct EmployeePrintVisitor : EmployeeVisitor {
				std::ostream &os;
				EmployeePrintVisitor(std::ostream &os_) : os(os_) {
				}
				
				void visit(const Developer &d) override {
				os << "Developer " << d.first_name << " " << d.last_name << " "
				<< d.language;
				}
				void visit(const SalesManager &sm) override {
				os << "SalesManager " << sm.first_name << " " << sm.last_name << " "
				<< sm.region;
				}
		} v(os);
		e.accept(v);
		return os;
}
```

Будет работать быстрее `dynamic_cast`

Виртуальные функции удобнее, если классы меняются часто, а функции редко

## Взаимодействие наследования и шаблонов

[https://github.com/egorSheremetov02/cpp-exam-summer-2021/blob/master/Наследование_и_классы.md#взаимодействие-наследования-и-шаблонов](https://github.com/egorSheremetov02/cpp-exam-summer-2021/blob/master/%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B8_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md#%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2)

Если мы хотим сами эмулировать наследование, то можно использовать оператор неявной конвертации - тогда шаблоны ломаются

В обычном наследовании все ок

```cpp
template<typename T>
struct Base {
    int x;
};

template<typename T
struct Derived1 : Base<T> {
};

template<typename T>
struct Derived2 {
    Base<T> b;

    operator Base<T> &() {
        return b;
    }
};

template<typename T>
void foo(Base<T> &) {
}
//с подстановкой int компилятор справится

int main() {
    Derived1<int> d1;
    foo(d1);

    Derived2<int> d2;
    foo(d2); //no
    foo<int>(d2); //yes

}
```

Можно использовать автовывод T - компилятор справится.  Можно указать T явно - ок (компилятор понимает, что ожидается Base от int, находит оператор приведения типа).

## Друзья и наследование + protected

[https://github.com/egorSheremetov02/cpp-exam-summer-2021/blob/master/Наследование_и_классы.md#друзья-и-protected](https://github.com/egorSheremetov02/cpp-exam-summer-2021/blob/master/%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B8_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md#%D0%B4%D1%80%D1%83%D0%B7%D1%8C%D1%8F-%D0%B8-protected)

Друзья работают только для фиксированного конкретного класса, к наследникам не переходят.

```cpp
struct Base {
 private:
    int x = 0;
 };
 
 struct Derived1 : Base {
 private:
    int y = 0;
    friend void foo();
 };
 
 struct Derived2 : Derived1 {
 private:
    int z = 0;
 };
 
 void foo(){
    Derived2 d2;
		// доступ для void foo()
    d2.x++; //нет доступа
    d2.y++; //есть
    d2.z++; //нет
 }
```

`friend` о наследовании ничего не знает, а `protected` и `private` поля для него одно и то же

## Проблема круга-квадрата и её решения (ограничение интерфейса на чтение/запись, убирание прямого наследования)

[https://github.com/egorSheremetov02/cpp-exam-summer-2021/blob/master/Наследование_и_классы.md#проблема-круга-квадрата-и-решенияcircle-ellipse](https://github.com/egorSheremetov02/cpp-exam-summer-2021/blob/master/%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B8_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B.md#%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0-%D0%BA%D1%80%D1%83%D0%B3%D0%B0-%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82%D0%B0-%D0%B8-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8Fcircle-ellipse)

Непонятно как наследовать (кто наследник, а кто базовый)

1. Круг - частный случай эллипса
2. Эллипс - частный случай круга

```cpp
// OK
struct Circle {

    virtual void setRadius(int r);

};

struct Ellipse : Circle {

    virtual void setRadius(int r); // устанавливает w и h - нет противоречий
    virtual void setWidth(int w);
    virtual void setHeight(int h);

};

// BAD
struct Circle {
    virtual int getRadius();
};

struct Ellipse : Circle {
    virtual int getRadius() { ????????????? } // при различных w и h непонятно что возвращать
    virtual int getWidth();
    virtual int getHeight();
};
```

```cpp
// OK
struct Ellipse {
    virtual int getWidth();
    virtual int getHeight();
};

struct Circle : Ellipse {
    int getRadius();
};
int getWidth(); //спокойно возвращают просто радиус, если круг
int getHeight();

// BAD
struct Ellipse {
    virtual void setWidth(int w);
    virtual void setHeight(int h);
};

struct Circle : Ellipse {
    virtual void setWidth() { ..... } // можем сделать что устанавливаем w и h радиусом
    void setRadius(int r);
};

//но ломается тест: 
Ellipse &e = ......
e.setWidth(10);
e.setHeight(20);
assert(e.width() == 10);
assert(e.height() == 20);
```

бытовая/математическая логика не работает для программирования и нужно выбирать, что конкретно подходит под вашу программу, либо просто не использовать в данном случае наследование
