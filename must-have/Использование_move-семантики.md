Подробно про move-семантику можно почитать [тут](https://drive.google.com/file/d/1Pq5aPj6sIkDfRrXDEqX57DS-ZUWkJsYJ/view)

## Эффективная инициализация полей класса из аргументов, принятых по значению или по rvalue-ссылке
Если в конструкторе принимается объект по значению, мы можем сделать `std::move`, чтобы избежать лишнего копирования. В таком случае мы не испортим объект, так как он все равно копировался при передаче

При передаче по `rvalue-ссылке` тоже можно сделать `std::move`, так как считается что объект временный и его можно портить (может оказаться в moved-from состоянии)

## moved-from состояние у объектов: может быть не определено, может быть невозможно обнаружить, пример ошибки
После перемещения, согласно move-семантике объект остается в каком-то корректном состоянии, однако не гарантируется в каком.
```C++
std::vector v1 = std::move(v2)
```
После перемещения `v2` будет в корректном, но неопределенном состоянии. Поэтому после перемещения стоит сделать `v2.clear()` и работать с вектором в определенном состоянии (только если нам `v2` нужен)

У `unique_ptr` определено moved-from состоянии - `nullptr`

## Отсутствие необходимости `move` из результата функции, возвращённого по значению
1. `move` возвращаемого из функции значения стоит писать только если мы хотим вернуть `rvalue`. В противном случае писать `std::move` не нужно (и плохо!), так как он может отключить `return-value-optimization` (если она там включалась), а если ее нет - мы зачем-то сделали лишнее перемещение
2. `Не надо писать вот так`
```C++
std::vector create_vec();

std::vector v = std::move(create_vec());
```
Достаточно будет написать вот так
```C++
std::vector create_vec();

std::vector v = create_vec();
```
Так как выражение `create_vec()` имеет тип `vector` и категорию `rvalue`

## Необходимость move для явной передачи владения `unique_ptr`
`unique_ptr` может иметь лишь одного прямого владельца. У него запрещены копирующий конструктор и копирующий оператор присваивания. Поэтому нужно сделать `std::move`, чтобы передать владение `unique_ptr`. Старый владелец переходит в moved-from состояние и перестает ссылаться на изначальный объект.

## Почему `std::move` не выполняет никакого кода
Он меняет категорию значения и аналогичен `static_cast<T&&>`, поэтому не выполняет никакого кода

Кто же тогда выполняет код? `Ответ` - либо конструктор перемещения, либо оператор перемещения, либо вообще кто-нибудь принявший rvalue-ссылку.
