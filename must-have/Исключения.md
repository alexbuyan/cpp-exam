## Синтаксис `try`/`catch`/`throw`, включая `catch (...)` и `throw;` (но без function-try-block)
```C++
void do_something() {
    ...
    if (error) {
        throw std::runtime_error("Something went wrong"); // так выглядит throw
    }
    ...
}

int foo() {
    try {
        do_something(); // здесь вылетают исключения
    } catch (const std::exception &e) { // А здесь они ловятся
        std::cout << e.what() << std::endl;
    } catch (...) { // Специальный случай: если среди обработанных исключений нет текущего, то заходим сюда
        throw; // Перебросили текущее исключение
    }
}
```

### Комбинации всяких `try`/`catch`
* Можно ли написать `throw` не в функции, а сразу в `try`? `Да`
* Можно ли `throw` в `try`? `Да`
* Можно ли вкладывать `try` друг в друга? `Да, но зачем`
* Можно ли `throw;` написать в `do_something`? `Да`
* Можно ли `throw;` написать в `catch (const std::exception &e)`, а не в `catch (...)`, будет ли принципиально отличаться от `throw e;`? `Можно, не будет`
* Когда надо писать `catch (...) { throw; }`? `Никогда, это бессмысленно`
* Может ли исключение вылететь из функции, внутри которой нет ни одного throw? `может, потому что можно вызвать кидающую функцию`

## Раскрутка стека: автоматический вызов деструкторов, в том числе в `new`/`new[]`, конструкторе, конструкторах полей
Если где-нибудь возникает `throw`, то компилятор начинает выполнять раскрутку стека (automatic storage duration): начинает идти вверх по стеку, т.е. делает `return` из функций по очереди (`return` в смысле - удалили локальные переменные и немедленно завершили выполнять код функции), пока не встретит `try`/`catch`, далее ищет соответствующий `catch` и выполняет его, если находит. Если вылетело исключение, то код дальше не исполняется.

Нужно понимать, что в момент выкидывания исключения через `throw`, все созданные объекты на текущем уровне сразу удаляются (у них корректно вызываются деструкторы в порядке, обратном созданию) и код дальше не выполняется.
* `catch` будет обрабатывать все исключения, выкинутые из блока `try`
* `catch` не обрабатывает исключения, выкинутые из другого `catch` на текущем уровне
* Необработанное исключение летит по уровням вверх, уничтожая все объекты на каждом уровне, пока не попадет в `try` или в `main` (если попадет в `main`, то программа завершится с данной ошибкой)

Деструкторы не всегда вызываются у объектов: если компилятор видит, что программа все равно завершится, то он может вырезать вызов деструкторов. Чтобы деструкторы всегда вызывались, каждому `throw` должен соответствовать свой `try`/`catch`.
```C++
int main() {
    try {
        int *x = new int(10); // Should be unique_ptr.
        foo(); // Код, бросающий исключение
        delete x;
    } catch (const std::exception &err) {
        std::cout << "Exception caught: " << err.what() << "\n";
    }
}
```
Следующий код Non exception-safe, переменная x не будет удалена. Чтобы этого избежать, все выносим в деструкторы.

### Про `new`/`new[]`, конструктор, конструктор полей

## Необходимость ловить исключения по ссылке
```C++
               ---> std::logic_error ---> std::invalid_argument
              /
std::exception
              \
               ---> std::runtime_error
```
Исключния: 
* наследуются
* `what()` - виртуальная функция

С помощью них очень удобно ловить исключения и узнавать ошибку через метод `what()` у `std::excetions`
```C++
void bar(int n) {
    if (n % 2 == 0) { 
        throw std::invalid_argument("N is even\n"); 
    }
}

void foo(int n) {
    try { 
        bar(n); 
    } catch (const std::runtime_error &err) {
        std::cout << "Caught runtime_error: " << err.what() << "\n";
    }
}

int main() {
    try {
        foo(2);
    } catch (const std::exception &err) {  // Reference!
        std::cout << "Exception caught: " << err.what() << "\n";
    }
}
```
#### Зачем принимать по ссылке
Если принимать не по ссылке, то будет slicing и метод `what()` будет уже чем-то непонятным. Более того, `std::exception` - это полиморфный класс, его лучше не ловить по значению.

## exception safety: определения no/basic/strong/nothrow
#### no safety
Если вылетело исключение, у программы может возникнуть некорректное состояние (утечки памяти, нарушение инвариантов)
```C++
foo *x = new foo[2];
do_smth();
delete[] x;
```
В `do_smth()` вылетело исключение и произойдет утечка памяти, так как не вызвали `delete[]`

#### basic
Отсутствие утечек ресурсов и сохранение инвариантов класса
```C++
struct WeirdObject {
    WeirdObject() {}
    WeirdObject(WeirdObject &&) {}
    WeirdObject & operator=(WeirdObject &&) { return *this; }
    WeirdObject(const WeirdObject &) = delete;
    WeirdObject & operator=(const WeirdObject &) = delete;
};

int main(){
    std::vector<WeirdObject> a(1'000'000);
    a.push_back(20); // Если вылетело исключение, то вектор 'a' уже мог измениться
    assert(a.size() == 1'000'000 || a.size() == 1'000'001); // Может быть неверно из-за базовой гарантии
}
```

#### strong
Исключение вылетает, но состояние программы от этого не меняется.
```C++
std::vector<int> a(1'000'000);
a.push_back(20);  // Если не получилось, то вектор 'a' не изменился
```

#### nothrow
Код никогда не кидает исключения
```C++
int a = 10, b = 20;
a = b;
```

## Умение добавить базовую гарантию в произвольный код при помощи автоматических выполняемых деструкторов
Вместо выделения памяти руками через `new` лучше использовать `unique_ptr`, тогда если вылетит исключение он освободит память в деструкторе.
```C++
int main() {
    try {
        int *x = new int(10); // Should be unique_ptr.
        foo(); // Код, бросающий исключение
        delete x;
    } catch (const std::exception &err) {
        std::cout << "Exception caught: " << err.what() << "\n";
    }
}

МЕНЯЕМ НА

int main() {
    try {
        std::unique_ptr<int> p = std::make_unique<int>();
        foo(); // Код, бросающий исключение
    } catch (const std::exception &err) {
        std::cout << "Exception caught: " << err.what() << "\n";
    }
}
```

```C++
FILE *f = fopen("a.txt", "r");
do_something(f);  // может выкинуть исключение
fclose(f);
```
Стоит завернуть f в класс с деструктором, чтобы обеспечить базовую гарантию. Подробнее [тут](https://github.com/hse-spb-2020-cpp/practice-suvorov/blob/master/20-210304/01-c-io/03-c-io-raii-exception.cpp)
