## Синтаксис `try`/`catch`/`throw`, включая `catch (...)` и `throw;` (но без function-try-block)
```C++
void do_something() {
    ...
    if (error) {
        throw std::runtime_error("Something went wrong"); // так выглядит throw
    }
    ...
}

int foo() {
    try {
        do_something(); // здесь вылетают исключения
    } catch (const std::exception &e) { // А здесь они ловятся
        std::cout << e.what() << std::endl;
    } catch (...) { // Специальный случай: если среди обработанных исключений нет текущего, то заходим сюда
        throw; // Перебросили текущее исключение
    }
}
```

## Раскрутка стека: автоматический вызов деструкторов, в том числе в `new`/`new[]`, конструкторе, конструкторах полей
Если где-нибудь возникает `throw`, то компилятор начинает выполнять раскрутку стека (automatic storage duration): начинает идти вверх по стеку, т.е. делает `return` из функций по очереди, пока не встретит `try`/`catch`, далее ищет соответствующий `catch` и выполняет его, если находит. Если вылетело исключение, то код дальше не исполняется.

Нужно понимать, что в момент выкидывания исключения через `throw`, все созданные объекты на текущем уровне сразу удаляются (у них корректно вызываются деструкторы) и код дальше не выполняется.
* `catch` будет обрабатывать все исключения, выкинутые из блока `try`
* `catch` не обрабатывает исключения, выкинутые из другого `catch` на текущем уровне
* Необработанное исключение летит по уровням вверх, уничтожая все объекты на каждом уровне, пока не попадет в `try` или в `main` (если попадет в `main`, то программа завершится с данной ошибкой)

Деструкторы не всегда вызываются у объектов: если компилятор видит, что программа все равно завершится, то он может вырезать вызов деструкторов. Чтобы деструкторы всегда вызывались, каждому `throw` должен соответствовать свой `try`/`catch`.
```C++
int main() {
    try {
        int *x = new int(10); // Should be unique_ptr.
        foo(); // Код, бросающий исключение
        delete x;
    } catch (const std::exception &err) {
        std::cout << "Exception caught: " << err.what() << "\n";
    }
}
```
Следующий код Non exception-safe, переменная x не будет удалена. Чтобы этого избежать, все выносим в деструкторы.

## Необходимость ловить исключения по ссылке
```C++
               ---> std::logic_error ---> std::invalid_argument
              /
std::exception
              \
               ---> std::runtime_error
```
С помощью них очень удобно ловить исключения и узнавать ошибку через метод `what()` у `std::excetions`
```C++
void bar(int n) {
    if (n % 2 == 0) { 
        throw std::invalid_argument("N is even\n"); 
    }
}

void foo(int n) {
    try { 
        bar(n); 
    } catch (const std::runtime_error &err) {
        std::cout << "Caught runtime_error: " << err.what() << "\n";
    }
}

int main() {
    try {
        foo(2);
    } catch (const std::exception &err) {  // Reference!
        std::cout << "Exception caught: " << err.what() << "\n";
    }
}
```
#### Зачем принимать по ссылке
Если принимать не по ссылке, то будет slicing и метод `what()` будет уже чем-то непонятным. Более того, `std::exception` - это полиморфный класс, его лучше не ловить по значению.

## exception safety: определения no/basic/strong/nothrow
#### no safety
Если вылетело исключение, у программы может возникнуть некорректное состояние (утечки памяти, нарушение инвариантов)
```C++
foo *x = new foo[2];
do_smth();
delete[] x;
```
В `do_smth()` вылетело исключение и произойдет утечка памяти, так как не вызвали `delete[]`

#### basic
Отсутствие утечек ресурсов и сохранение инвариантов класса
```C++
struct WeirdObject {
    WeirdObject() {}
    WeirdObject(WeirdObject &&) {}
    WeirdObject & operator=(WeirdObject &&) { return *this; }
    WeirdObject(const WeirdObject &) = delete;
    WeirdObject & operator=(const WeirdObject &) = delete;
};

int main(){
    std::vector<WeirdObject> a(1'000'000);
    a.push_back(20); // Если вылетело исключение, то вектор 'a' уже мог измениться
    assert(a.size() == 1'000'000 || a.size() == 1'000'001); // Может быть неверно из-за базовой гарантии
}
```

#### strong
Исключение вылетает, но состояние программы от этого не меняется.
```C++
std::vector<int> a(1'000'000);
a.push_back(20);  // Если не получилось, то вектор 'a' не изменился
```

#### nothrow
Код никогда не кидает исключения
```C++
int a = 10, b = 20;
a = b;
```

## Умение добавить базовую гарантию в произвольный код при помощи автоматических выполняемых деструкторов
Вместо выделения памяти руками через `new` лучше использовать `unique_ptr`, тогда если вылетит исключение он освободит память в деструкторе.
```C++
{
    std::unique_ptr<T> p = std::make_unique<T>();
} // calls ~T 1 time

{
    std::unique_ptr<T[]> p(new T[3]);
} // calls ~T 3 times

{
    std::unique_ptr<T, std::function<void(T*)>> p(new T, [](T* ptr) {
        std::cout << "destroying from a custom deleter...\n";
        delete ptr;
    });  // p owns T
} // the lambda above is called and D is destroyed
```
