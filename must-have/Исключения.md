## Синтаксис `try`/`catch`/`throw`, включая `catch (...)` и `throw;` (но без function-try-block)
```C++
void do_something() {
    ...
    if (error) {
        throw std::runtime_error("Something went wrong"); // так выглядит throw
    }
    ...
}

int foo() {
    try {
        do_something(); // здесь вылетают исключения
    } catch (const std::exception &e) { // А здесь они ловятся
        std::cout << e.what() << std::endl;
    } catch (...) { // Специальный случай: если среди обработанных исключений нет текущего, то заходим сюда
        throw; // Перебросили текущее исключение
    }
}
```

## Раскрутка стека: автоматический вызов деструкторов, в том числе в `new`/`new[]`, конструкторе, конструкторах полей
Если где-нибудь возникает `throw`, то компилятор начинает выполнять раскрутку стека (automatic storage duration): начинает идти вверх по стеку, т.е. делает `return` из функций по очереди, пока не встретит `try`/`catch`, далее ищет соответствующий `catch` и выполняет его, если находит. Если вылетело исключение, то код дальше не исполняется.

Нужно понимать, что в момент выкидывания исключения через `throw`, все созданные объекты на текущем уровне сразу удаляются (у них корректно вызываются деструкторы) и код дальше не выполняется.
* `catch` будет обрабатывать все исключения, выкинутые из блока `try`
* `catch` не обрабатывает исключения, выкинутые из другого `catch` на текущем уровне
* Необработанное исключение летит по уровням вверх, уничтожая все объекты на каждом уровне, пока не попадет в `try` или в `main` (если попадет в `main`, то программа завершится с данной ошибкой)

Деструкторы не всегда вызываются у объектов: если компилятор видит, что программа все равно завершится, то он может вырезать вызов деструкторов. Чтобы деструкторы всегда вызывались, каждому `throw` должен соответствовать свой `try`/`catch`.
```C++
int main() {
    try {
        int *x = new int(10); // Should be unique_ptr.
        foo(); // Код, бросающий исключение
        delete x;
    } catch (const std::exception &err) {
        std::cout << "Exception caught: " << err.what() << "\n";
    }
}
```
Следующий код Non exception-safe, переменная x не будет удалена. Чтобы этого избежать, все выносим в деструкторы.

## Необходимость ловить исключения по ссылке
```C++
               ---> std::logic_error ---> std::invalid_argument
              /
std::exception
              \
               ---> std::runtime_error
```
С помощью них очень удобно ловить исключения и узнавать ошибку через метод `what()` у `std::excetions`
```C++
void bar(int n) {
    if (n % 2 == 0) { 
        throw std::invalid_argument("N is even\n"); 
    }
}

void foo(int n) {
    try { 
        bar(n); 
    } catch (const std::runtime_error &err) {
        std::cout << "Caught runtime_error: " << err.what() << "\n";
    }
}

int main() {
    try {
        foo(2);
    } catch (const std::exception &err) {  // Reference!
        std::cout << "Exception caught: " << err.what() << "\n";
    }
}
```
#### Зачем принимать по ссылке
Если принимать не по ссылке, то будет slicing и метод `what()` будет уже чем-то непонятным. Более того, `std::exception` - это полиморфный класс, его лучше не ловить по значению.

## exception safety: определения no/basic/strong/nothrow

## Умение добавить базовую гарантию в произвольный код при помощи автоматических выполняемых деструкторов
