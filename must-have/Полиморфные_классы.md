## Виртуальные методы и их отличия от невиртуальных
`Виртуальная функция` — это функция, которая определяется в базовом классе, а любой порожденный класс может ее переопределить.
```C++
struct Base {
    virtual void foo() {
        std::cout << "Base::foo()\n";
    }
};

struct Derived : Base {
    void foo() override /* C++11 */ { // override: добавить virtual, проверить, что в родителе virtual есть.
                                      // На самом деле virtual добавляется автоматически, если был в родителе.
        std::cout << "Derived::foo()\n";
    }
};
int main() {
    Base b;
    Derived d;
    b.foo(); //здесь вызовется foo из Base
    d.foo(); //здесь вызовется foo из Derived
    Base &db = d;
    db.foo(); //вызовется Derived, без virtual вызвалось бы Base
}
```
Виртуальная функция отличается об обычной функции тем, что для обычной функции связывание вызова функции с ее определением осуществляется на этапе компиляции. Для виртуальных функций это происходит во время выполнения программы.

## Необходимость виртуального деструктора
### Проблема
```C++
struct Human {
	std::string first_name, last_name; // Possibly wrong.
	Human(std::string first_name_, std::string last_name_)
	: first_name(std::move(first_name_)), last_name(std::move(last_name_)) {
}
};

struct Student : Human {
	std::string group; // Possibly wrong.
	Student(std::string first_name_, std::string last_name_, std::string group_)
		: Human(std::move(first_name_), std::move(last_name_))
		, group(std::move(group_)) {}
};

int main() {
	Human *h = new Student("Egor", "Suvorov", "MBD191");
	delete h; // UB: ~Human()
	// delete static_cast<Student*>(h); // Would be OK.
}
```
`Проблема`: в данном случае вызывается деструктор от `Human`, а нужно вызывать деструктор от `Student`

### Решение - виртуальный деструктор
```C++
virtual ~Human() = default;
```
Теперь во всех производных классах деструкторы автоматически становятся виртуальными

## Чисто виртуальные функции, что происходит при отсутствии `override` или `virtual`
`Чисто виртуальный метод` - у метода нет реализации, ее должен предоставить кто-то из наследников. Если в классе есть виртуальный метод, то класс - `абстрактный` (такой класс обычно не используется сам по себе). Если метод чисто виртуальный, то не перезаписать его (`override`) не страшно (ошибки компиляции не будет), однако если не сделать реализацию в наследнике, то наследник тоже станет абстрактным классом.
```C++
struct Base {
virtual void foo() const = 0; // Base::foo() - чисто виртуальный метод.
};
struct Derived : Base {
// void foo() override {}
// Так как foo() нет, то Derived::foo() - чисто виртуальный метод.
// Следствие: Derived - "абстрактный класс".
};
void foo(const Base &b) {
b.foo();
}
int main() {
Derived d; // Запрещено создавать абстрактные классы.
foo(d);
}
```

## Slicing (срезка объектов) при присваивании полиморфного класса в переменную типа "базовый класс", как защититься (хранить только ссылки/умные указатели)

## Хранение полиморфных объектов в контейнерах

## `dynamic_cast` для полиморфных классов (по указателям и ссылкам)
