## Виртуальные методы и их отличия от невиртуальных

## Необходимость виртуального деструктора

## Чисто виртуальные функции, что происходит при отсутствии `override` или `virtual`
```C++
struct Base {
    virtual void foo() {
        std::cout << "Base::foo()\n";
    }
};

struct Derived : Base {
    void foo() override /* C++11 */ { // override: добавить virtual, проверить, что в родителе virtual есть.
                                      // На самом деле virtual добавляется автоматически, если был в родителе.
        std::cout << "Derived::foo()\n";
    }
};
int main() {
    Base b;
    Derived d;
    b.foo(); //здесь вызовется foo из Base
    d.foo(); //здесь вызовется foo из Derived
    Base &db = d;
    db.foo(); //вызовется Derived, без virtual вызвалось бы Base
}
```

## Slicing (срезка объектов) при присваивании полиморфного класса в переменную типа "базовый класс", как защититься (хранить только ссылки/умные указатели)

## Хранение полиморфных объектов в контейнерах

## `dynamic_cast` для полиморфных классов (по указателям и ссылкам)
