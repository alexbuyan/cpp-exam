`Полиморфный класс` <=> есть хотя бы одна виртуальная функция
## Виртуальные методы и их отличия от невиртуальных
`Виртуальная функция` — это функция, которая определяется в базовом классе, а любой порожденный класс может ее переопределить.
```C++
struct Base {
    virtual void foo() {
        std::cout << "Base::foo()\n";
    }
};

struct Derived : Base {
    void foo() override /* C++11 */ { // override: добавить virtual, проверить, что в родителе virtual есть.
                                      // На самом деле virtual добавляется автоматически, если был в родителе.
        std::cout << "Derived::foo()\n";
    }
};
int main() {
    Base b;
    Derived d;
    b.foo(); //здесь вызовется foo из Base
    d.foo(); //здесь вызовется foo из Derived
    Base &db = d;
    db.foo(); //вызовется Derived, без virtual вызвалось бы Base
}
```
Виртуальная функция отличается об обычной функции тем, что для обычной функции связывание вызова функции с ее определением осуществляется на этапе компиляции. Для виртуальных функций это происходит во время выполнения программы.

## Необходимость виртуального деструктора
### Проблема
```C++
struct Human {
	std::string first_name, last_name; // Possibly wrong.
	Human(std::string first_name_, std::string last_name_)
	: first_name(std::move(first_name_)), last_name(std::move(last_name_)) {
}
};

struct Student : Human {
	std::string group; // Possibly wrong.
	Student(std::string first_name_, std::string last_name_, std::string group_)
		: Human(std::move(first_name_), std::move(last_name_))
		, group(std::move(group_)) {}
};

int main() {
	Human *h = new Student("Egor", "Suvorov", "MBD191");
	delete h; // UB: ~Human()
	// delete static_cast<Student*>(h); // Would be OK.
}
```
`Проблема`: в данном случае вызывается деструктор от `Human`, а нужно вызывать деструктор от `Student`

### Решение - виртуальный деструктор
```C++
virtual ~Human() = default;
```
Теперь во всех производных классах деструкторы автоматически становятся виртуальными

## Чисто виртуальные функции, что происходит при отсутствии `override` или `virtual`
`Чисто виртуальный метод` - у метода нет реализации, ее должен предоставить кто-то из наследников. Если в классе есть виртуальный метод, то класс - `абстрактный` (такой класс обычно не используется сам по себе). Если метод чисто виртуальный, то не перезаписать его (`override`) не страшно (ошибки компиляции не будет), однако если не сделать реализацию в наследнике, то наследник тоже станет абстрактным классом.
```C++
struct Base {
    virtual void foo() const = 0; // Base::foo() - чисто виртуальный метод.
};
struct Derived : Base {
    // void foo() override {}
    // Так как foo() нет, то Derived::foo() - чисто виртуальный метод.
    // Следствие: Derived - "абстрактный класс".
};

void foo(const Base &b) {
    b.foo();
}

int main() {
    Derived d; // Запрещено создавать абстрактные классы.
    foo(d);
}
```
В этом случае объект `Derived` можно создавать:
```C++
struct Base {
    virtual void foo() const = 0; // Base::foo() - чисто виртуальный метод.
};

struct Derived : Base {
    void foo() const override {
    }
    // Derived::foo() - обычный виртуальный метод.
    // Derived - обычный класс, не абстрактный.
};

// void bar(Base b) { // Запрещено создавать объекты типа "абстрактный класс".
// }

int main() {
    Derived d;
    foo(d);
}
```
Чисто виртуальные методы нельзя вызывать напрямую из базового класса:
```C++
#include <iostream>

struct Base {
    virtual void foo() = 0;
};

struct Derived : Base {
    void foo() override {
        Base::foo();  // Link error.
        std::cout << "Derived\n";
    }
};

int main() {
    Derived d;
    d.foo();

    d.Base::foo();  // Link error.
}
```
Виртуальные методы можно сделать final, чтобы в наследнике наследника его переопределить не получилось:
```C++
struct Base {
    virtual void foo() = 0;
};

struct Derived : Base {
    void foo() override final {
    }
};

struct MegaDerived : Derived {
    void foo() override { //здесь ошибка
    }
};
```

## Slicing (срезка объектов) при присваивании полиморфного класса в переменную типа "базовый класс", как защититься (хранить только ссылки/умные указатели)
```C++
// Так нельзя
Derived d;
Base b = d; //slicing

// Так можно
Derived d;
Base &b = d; //basecast или upcast

Derived d;
Derived *dptr = &d;
Base *bptr = dptr;
```

## Хранение полиморфных объектов в контейнерах
```C++
#include <iostream>
#include <vector>

struct Human {
    std::string first_name, last_name;
};

struct Student : Human {
    std::string group; 

int main() {
    std::vector<Human> people;
    std::vector<Student> students;
}
```
Вектор выделяет память для `Human`, тогда мы не можем добавить `Student`. Отдельно делать векторы для `Human` и `Student` странно, зачем тогда наследование. 

Нужно использовать `unique_ptr`
```C++
std::vector<std::unique_ptr<Human>> people;
```
Каждый элемент вектора - указатель на Human и Student, тогда объекты могут иметь разные типы, занимать разное место в памяти, а вектору норм, потому что он знает размер указателя. При удалении вектор вызовет деструктор у умных указателей, а они вызовут удаление у всех объектов (здесь нужны виртуальный деструкторы). Без указателя будет `slicing`

## `dynamic_cast` для полиморфных классов (по указателям и ссылкам)
`dynamic_cast` нужен, чтобы проверить верно ли, что какой-то объект данного типа работает с указателями (с ссылками он похож на `static_cast`, так как предполагает, что конвертация всегда успешная, иначе вызывает ошибку компиляции). В случае с указателями `dynamic_cast` возвращает либо `nullptr`, если конвертация прошла неуспешно, в другой случае возвращает указатель. `dynamic_cast` работает только если `Base` - полиморфный (потому что создается таблица виртуальных функций и в ней мы можем сравнить указатели).
```C++
struct Base {  
    virtual void foo() {};  
};  
  
struct Derived1 : Base {  
//    void foo() override {}  
};  
  
void f(const Base &b) {  
    // dynamic_cast работает только если Base "полиморфный".  
    // Класс "полиморфный" <=> есть хотя бы одна виртуальная функция (обычно есть виртуальный деструктор).  
    const Derived1 *d1 = dynamic_cast<const Derived1*>(&b);
    if (d1) {
    	std::cout << "Derived1\n";
    }
}
```
