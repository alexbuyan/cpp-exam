## Базовое использование `thread` (включая `join()`), `mutex` и `unique_lock`
### `std::thread`
`std::thread` - поток. Существует несколько способов создания потока
* `std::thread` c использованием лямбды
```C++
std::thread t([&]() {
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    std::cout << "Hello from thread! data=" << data << "\n";
    data += 10;
});
```
Просто передаем лямбду в конструктор. `[&]` - означает, что передаем все видимые переменные по ссылке (то есть можем пользоваться ими внутри потока).
* `std::thread` с явным указанием функции и ее параметров
```C++
void worker(int a, int &b) {
    std::cout << "Thread: " << a << " " << &b << "\n";
}

int main() {
    ...
    std::thread t(worker, a, std::ref(b));
    t.join();
}
```
`Важно`: всегда передаются копии параметров (если все-таки хотим передать ссылку, то надо явно писать `std::ref()`)

Если `main` закончится раньше, чем какой-то поток, то, строго говоря, происходят утечки (например в потоке могла выделиться память на куче, которую надо почистить, сам стек тоже надо почистить). Для этого нужен `.join()` - программа ждет, пока поток завершится, и освобождает его ресурсы. 

`.detach()` - обещаем больше не делать `join()`, теперь ОС отвечает за сборку мусора в потоке. Возникает только если нам вообще ничего от потока никогда не будет нужно. Единственный разумный пример: мы создаём сетевой сервер, который в бесконечном цикле плодит потоки для клиентов.

### `std::mutex`
`std::mutex` - переменная, которую можно захватывать и всего один поток может это сделать, а если попытается другой поток захватить, а её ещё не отпустили, то этот поток начинает её "ждать".
```C++
void function(const char *s) {
    std::mutex m;
    m.lock();
    for (int i = 0; s[i]; i++) {
        std::cout << s[i];
    }
    m.unlock();
}

WARNING: должен быть только один mutex!
ANSWER:
1. Сделать глобальной переменной
2. Сделать static переменной
```

### `std::unique_lock`
`std::unique_lock` - захватывает `std::mutex` при создании и отпускает при удалении
```C++
void function(const char *s) {
    std::unique_lock l{m};
    for (int i = 0; s[i]; i++) {
        std::cout << s[i];
    }
}

WARNING:
Нельзя писать std::unique_lock{m}; т.к. тогда объект уничтожается при ";"
```

## Гонки: пример гонки данных и гонки при выводе на экран, как избежать, умение видеть гонки в произвольном несложном коде
* Вывод на экран
```C++
void writeln(const char *s) {
    for (int i = 0; s[i]; i++) {
        std::cout << s[i];
    }
    std::cout << '\n';
}

int main() {
    std::thread t([]() {
        for (;;) {
            writeln("Hello from the second thread");
        }
    });
    for (;;) {
        writeln("Hello from the main thread");
    }
    return 0;
}
```
Гонка происходит не смотря на потокобезопасность `std::cout`, посколько функции вызываются независимо, а значит оба цикла могут работать одновременно.
* По данным
```C++
int data = 0;

auto worker = [&data]() {
    for (int i = 0; i < N; i++) {
        data++;
    }
};

std::thread t(worker);
for (int i = 0; i < M; i++) {
    if (data % 2 == 0) {
        // нет никакой гарантии, что уже на этой строчке data % 2 == 0
        std::cout << "data is " << data << " (in progress)\n";
    }
}
t.join();

std::cout << "data is " << data << "\n";
```
В данном случае может произойти так, что выведется нечетное значение. Так происходит, потому что между проверкой и выводом, внутри потока (который захватил `data` по ссылке - может произойти изменение).

На самом деле тут без `std::mutex` вообще `UB`, так как один поток меняет переменную, а другой из неё в это же время читает

Чтобы избежать гонки данных, следует воспользоваться `std::mutex`. Еще можно использовать атомарные снимки (снятие снимка - сохраняем значение в новую переменную и работаем с ней)
```C++
std::mutex m;
int data = 0;
auto worker = [&data, &m]() {
    for (int i = 0; i < N; i++) {
        std::unique_lock l{m};
        data++;
    }
};
std::thread t1(worker);
std::thread t2(worker);
for (int i = 0; i < M; i++) {
    std::unique_lock l(m);
    int data_snapshot = data;
    l.unlock();  // Не m.unlock()! Иначе unique_lock сделает unlock() ещё раз, это UB.

    if (data_snapshot % 2 == 0) {
        std::cout << "data is " << data_snapshot << " (in progress)\n";
    }
}
t2.join();
t1.join();
std::cout << "data is " << data << "\n";
```
