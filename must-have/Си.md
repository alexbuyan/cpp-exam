## Использование строк в стиле Си: отличия `char s[10]` и `const char *s`, хранение в структурах, преобразование с `std::string`
Для хранения строк используется массив байт `char arr[N]`, где `N` - `длина строки + 1` (так как массив всегда должен заканчиваться 0 символом). Можем завести указатель на строчку и вывести ее
```C++
char arr[] = "Hello";
// char arr[] = {'H', 'e', 'l', 'l', 'o', 0 /*'\0'*/};
std::cout << sizeof(arr) << "\n";

char *str = arr;
std::cout << str << "\n";
```
Если в конце не будет `\0` символа - `UB`

`char s[]` - массив байт

`char *s` - указатель на массив байт (не обязательно начало)

Если хранится массив `char`, то можем быстро записывать в файл и читать из него эту информацию. Но с `char*` такое уже не прокатит. Тк просто запишутся указатели да память для этого конкретного файла. Аналогично будет и для `std::string`
```C++
struct Person {
    char first_name[31]{};
    char last_name[31]{};
};

int main() {
    {
        Person p;
        std::strcpy(p.first_name, "Konstantin");
        std::strcpy(p.first_name, "Ivan"); //Тут перезапишется, но будет остаток Константина^^
        std::strcpy(p.last_name, "Ivanov");
        {
            std::ofstream f("01.bin", std::ios::binary);
            f.write(reinterpret_cast<const char*>(&p), sizeof p);
        }
    }      
    {
        Person p;
        {
            std::ifstream f("01.bin", std::ios::binary);
            f.read(reinterpret_cast<char*>(&p), sizeof p);
        }
        std::cout << p.first_name << "\n";
        std::cout << p.last_name << "\n";
    }
}

-------------------------------------------------------------------------------------

struct Person {
    char *first_name;
    char *last_name;
    /*
    std::string first_name;
    std::string last_name;
    */
};

int main() {
    Person p;
    p.first_name = "Ivan";
    p.last_name = "Ivanov";

    {
        std::ofstream f("02.bin", std::ios::binary);
        f.write(reinterpret_cast<const char*>(&p), sizeof p);
    }
    /*
        std::ofstream f("03.bin", std::ios::binary);
        f.write(reinterpret_cast<const char*>(&p), sizeof p);  // UB.
        // Потому что std::string - не POD (plain old data). Точнее: не Trivial. Точнее: не TrivialCopyable.
        // Надо что-то такое (плюс как-то указать длину, чтобы можно было прочитать):
        f.write(p.first_name.data(), p.first_name.size());
    */
}
```

#### `std::string`
Это обёртка над сишными строками, которые умеют больше и сами следят за строкой, её размером и тд. Но можно попросить у `std::string` и сишную строку.
* `std::string::c_str()` - вернет копию строчки
* `std::string::data()` - вернет константный указатель на начало строки

## Операции со строками в стиле Си: конкатенция, получение длины, безопасная альтернатива для `gets` и `scanf("%s")`
Время жизни строкового литерала - `static`. За ним полностью следит компилятор, это константная память, её изменения запрещены. Поэтому указатели нужны константные.

### Конкатенация
```C++
/*
    char* a = "hello ";
    const char* b = "world";
    std::cout << (a + b) << "\n";
*/
//но так можно
std::cout << ("Hello" " World") << "\n";  // Костыль на этапе компиляции(!).
                                               // Только для литералов.
// std::cout << (a b) << "\n";             // Так тоже нельзя

void my_strcat(char *a, const char *b) {
    int a_pos = std::strlen(a);
    for (int b_pos = 0; b[b_pos]; b_pos++) {
        std::cout << "b_pos=" << b_pos << "\n";
        a[a_pos++] = b[b_pos];
    }
    a[a_pos] = 0;
}
```
Такой свой конкатенатор вызывает `UB`, потому что никто не гарантировал нам, что в память после этой строки можно еще что-то записывать

Попробуем написать лучше
```C++
void my_strcat(char *&a, const char *b) {
    char *out = new char[strlen(a) + strlen(b) + 1];

    std::strcpy(out, a);
    std::strcpy(out + strlen(a), b);

    delete[] a;
    a = out;
}
```
Такой код будет работать, но если создаем строку не через new, это работать не будет
```C++
// ОК, но очень странно выглядит.
char *a = new char[6];
std::strcpy(a, "hello");
char b[] = " world";
my_strcat(a, b);
// my_strcat(a + 1, b);  // UB: будет delete из середины куска памяти.
std::cout << a << "\n";
delete[] a;
```
Это `UB`, тк тут удаляем часть массива
```C++
char a[] = "hello";
char b[] = " world";
char *aptr = a;
my_strcat(aptr, b);
std::cout << aptr << "\n";
```

### Получение длины
```C++
char arr[] = "Hello World";
std::cout << std::strlen(arr) << "\n";      // 11
std::cout << std::strlen(arr + 3) << "\n";  // 8

// реализация
auto my_strlen = [&](const char *s){
    int len = 0;
    while (s[len] != 0) {
      len++;
    }
    return len;
};

std::cout << my_strlen(arr) << "\n";        // 11
std::cout << my_strlen(arr + 3) << "\n";    // 8
```

### Безопасная альтернатива для `gets` и `scanf("%s")`
#### `gets`
`gets` считывает строчку из стандартного потока ввода
```C++
char command[10];   //команда максимум из 9 символов
gets(command);  // Может случиться переполнение буфера (buffer overflow).
// Top-1 уязвимостей в мире: https://ulearn.me/course/hackerdom/Perepolnenie_steka_3bda1c2c-c2a1-4fb0-9146-fccc47daf93b
```
Чтобы не было переполнения буффера, ограничим его - воспользуемся `fgets` (но строка обрежется, если она будет больше, чем мы указали)
```C++
char command[10];
std::fgets(command, sizeof command, stdin);  // Всегда делает null-terminated строчку.
                                             // Обрезает ввод.
// Плюсовый std::string не обрезает, но может слопать всю память :(
```

#### `scanf("%s")`
`scanf` - ввода общего назначения, считывающей данные из пото­ка stdin. Она может считывать данные всех базовых типов и автоматически конвертировать их в нужный внутренний формат.
* %с Считать один символ
* %d Считать десятичное число целого типа
* %i Считать десятичное число целого типа
* %е Считать число с плавающей запятой
* %f Считать число с плавающей запятой
* %g Считать число с плавающей запятой
* %о Считать восьмеричное число
* %s Считать строку
* %х Считать шестнадцатиричное число
* %р Считать указатель
* %n Принимает целое значение, равное количеству считанных до текущего момента символов
* %u Считывает беззнаковое целое
* %[] Просматривает набор символов
* %% Считывает символ %

Может возникнуть `UB`
```C++
{
    char buf[5];
    int cnt = scanf("%s", buf);  // Potentially UB
    printf("cnt=%d, buf=|%s|\n", cnt, buf);
}
{
    char buf[5];
    int x;
    int cnt = scanf("%4s%d", buf, &x);  // No UB, will stop reading after 4 bytes.
    printf("cnt=%d, buf=|%s|, x=%d\n", cnt, buf, x);
}
```
Пример задачки
```C++
char s[10];
int x, y;
scanf("%d%s%d", &x, s, &y);  // Как исправить возможное UB? Как выглядит ввод, на котором это UB проявится?

// Решение
// UB мог возникнуть если строка будет длинее 9 символов
char s[10];
int x, y;
scanf("%d%9s%d", &x, s, &y);
```

## Массивы массивов в языке Си (вроде `int**`): выделение, освобождение, использование
Можно попросить многомерный массив, тогда элементы будут лежать подряд
```C++
int arr[3][4][5]{};
```
Но можем собрать и ручками. Отсюда несколько эффектов: 
* Теперь это несколько блоков в памяти, которые могут лежать не подряд
* Не все массивы должны быть одинаковой длины, мы сами управляем этим
```C++
int ***arr2 = new int**[3];
for (int i = 0; i < 3; i++) {
    arr2[i] = new int*[4];
    arr2[i][0] = new int[5];
    arr2[i][1] = new int[5];
    arr2[i][2] = new int[5];
    arr2[i][3] = new int[5];
}
arr2[1][2][3] = 123;
```
Массивы при передаче в функцию преобразовываются к указателю и теряют размер. Его нужно передавать отдельно.
```C++
// void foo(int arr[]) {  // То же самое, что int *arr
void foo(int arr[15]) {  // То же самое, что int *arr
    std::cout << sizeof(arr) << "\n"; // 8
}
```
* Просто как многомерный указатель, пропадают требования к размерам, но и самих размеров уже нет
```C++
void bar(int ***arr) {
    std::cout << arr[1][2][3] << "\n";
}
```
* Принимать именно указатель на массив в разных видах
```C++
using arr45 = int[4][5];
// void foo(int arr[3][4][5]) {
// void foo(int arr[][4][5]) {
// void foo(int (*arr)[4][5]) {  // What if: (*arr) --> *arr
void foo(arr45 *arr) {
    std::cout << arr[1][2][3] << "\n";
}
```
* Можно опять же сделать функцию шаблонной
```C++
template<std::size_t N, std::size_t M, std::size_t K>
void foo2(int (&arr)[N][M][K]) {
    std::cout << arr[1][2][3] << "\n";
    std::cout << N << " " << M << " " << K << "\n";
}
```
* В плюсах можно взять ссылку на массив. Тогда будет проверка, что сходятся размеры
```C++
void foo_cpp_wtf(int (&arr)[10]) {}  // C++ only, ok
```
* Можно функцию сделать шаблонной. Она будет принимать ссылку на массив размера `N`. `N` - шаблонный параметр
```C++
template<std::size_t N>
void foo_cpp_templ(int (&arr)[N]) {
    std::cout << "N=" << N << "\n";
}
```





