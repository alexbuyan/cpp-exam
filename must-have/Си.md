## Использование строк в стиле Си: отличия `char s[10]` и `const char *s`, хранение в структурах, преобразование с `std::string`
Для хранения строк используется массив байт `char arr[N]`, где `N` - `длина строки + 1` (так как массив всегда должен заканчиваться 0 символом). Можем завести указатель на строчку и вывести ее
```C++
char arr[] = "Hello";
// char arr[] = {'H', 'e', 'l', 'l', 'o', 0 /*'\0'*/};
std::cout << sizeof(arr) << "\n";

char *str = arr;
std::cout << str << "\n";
```
Если в конце не будет `\0` символа - `UB`

`char s[]` - массив байт

`char *s` - указатель на массив байт (не обязательно начало)

Если хранится массив `char`, то можем быстро записывать в файл и читать из него эту информацию. Но с `char*` такое уже не прокатит. Тк просто запишутся указатели да память для этого конкретного файла. Аналогично будет и для `std::string`
```C++
struct Person {
    char first_name[31]{};
    char last_name[31]{};
};

int main() {
    {
        Person p;
        std::strcpy(p.first_name, "Konstantin");
        std::strcpy(p.first_name, "Ivan"); //Тут перезапишется, но будет остаток Константина^^
        std::strcpy(p.last_name, "Ivanov");
        {
            std::ofstream f("01.bin", std::ios::binary);
            f.write(reinterpret_cast<const char*>(&p), sizeof p);
        }
    }      
    {
        Person p;
        {
            std::ifstream f("01.bin", std::ios::binary);
            f.read(reinterpret_cast<char*>(&p), sizeof p);
        }
        std::cout << p.first_name << "\n";
        std::cout << p.last_name << "\n";
    }
}

-------------------------------------------------------------------------------------

struct Person {
    char *first_name;
    char *last_name;
    /*
    std::string first_name;
    std::string last_name;
    */
};

int main() {
    Person p;
    p.first_name = "Ivan";
    p.last_name = "Ivanov";

    {
        std::ofstream f("02.bin", std::ios::binary);
        f.write(reinterpret_cast<const char*>(&p), sizeof p);
    }
    /*
        std::ofstream f("03.bin", std::ios::binary);
        f.write(reinterpret_cast<const char*>(&p), sizeof p);  // UB.
        // Потому что std::string - не POD (plain old data). Точнее: не Trivial. Точнее: не TrivialCopyable.
        // Надо что-то такое (плюс как-то указать длину, чтобы можно было прочитать):
        f.write(p.first_name.data(), p.first_name.size());
    */
}
```

#### `std::string`
Это обёртка над сишными строками, которые умеют больше и сами следят за строкой, её размером и тд. Но можно попросить у `std::string` и сишную строку.
* `std::string::c_str()` - вернет копию строчки
* `std::string::data()` - вернет константный указатель на начало строки

## Операции со строками в стиле Си: конкатенция, получение длины, безопасная альтернатива для `gets` и `scanf("%s")`
### Конкатенация
```C++
/*
    char* a = "hello ";
    const char* b = "world";
    std::cout << (a + b) << "\n";
*/
//но так можно
std::cout << ("Hello" " World") << "\n";  // Костыль на этапе компиляции(!).
                                               // Только для литералов.
// std::cout << (a b) << "\n";             // Так тоже нельзя

void my_strcat(char *a, const char *b) {
    int a_pos = std::strlen(a);
    for (int b_pos = 0; b[b_pos]; b_pos++) {
        std::cout << "b_pos=" << b_pos << "\n";
        a[a_pos++] = b[b_pos];
    }
    a[a_pos] = 0;
}
```
Такой свой конкатенатор вызывает `UB`, потому что никто не гарантировал нам, что в память после этой строки можно еще что-то записывать

Попробуем написать лучше
```C++
void my_strcat(char *&a, const char *b) {
    char *out = new char[strlen(a) + strlen(b) + 1];

    std::strcpy(out, a);
    std::strcpy(out + strlen(a), b);

    delete[] a;
    a = out;
}
```
Такой код будет работать, но если создаем строку не через new, это работать не будет
```C++
// ОК, но очень странно выглядит.
char *a = new char[6];
std::strcpy(a, "hello");
char b[] = " world";
my_strcat(a, b);
// my_strcat(a + 1, b);  // UB: будет delete из середины куска памяти.
std::cout << a << "\n";
delete[] a;
```
Это `UB`, тк тут удаляем часть массива
```C++
char a[] = "hello";
char b[] = " world";
char *aptr = a;
my_strcat(aptr, b);
std::cout << aptr << "\n";
```

### Получение длины

### Безопасная альтернатива для `gets` и `scanf("%s")`

## Массивы массивов в языке Си (вроде `int**`): выделение, освобождение, использование

