## Использование строк в стиле Си: отличия `char s[10]` и `const char *s`, хранение в структурах, преобразование с `std::string`
Для хранения строк используется массив байт `char arr[N]`, где `N` - `длина строки + 1` (так как массив всегда должен заканчиваться 0 символом). Можем завести указатель на строчку и вывести ее
```C++
char arr[] = "Hello";
// char arr[] = {'H', 'e', 'l', 'l', 'o', 0 /*'\0'*/};
std::cout << sizeof(arr) << "\n";

char *str = arr;
std::cout << str << "\n";
```
Если в конце не будет `\0` символа - `UB`

Если хранится массив `char`, то можем быстро записывать в файл и читать из него эту информацию. Но с `char*` такое уже не прокатит. Тк просто запишутся указатели да память для этого конкретного файла. Аналогично будет и для `std::string`
```C++
struct Person {
    char first_name[31]{};
    char last_name[31]{};
};

int main() {
    {
        Person p;
        std::strcpy(p.first_name, "Konstantin");
        std::strcpy(p.first_name, "Ivan"); //Тут перезапишется, но будет остаток Константина^^
        std::strcpy(p.last_name, "Ivanov");
        {
            std::ofstream f("01.bin", std::ios::binary);
            f.write(reinterpret_cast<const char*>(&p), sizeof p);
        }
    }      
    {
        Person p;
        {
            std::ifstream f("01.bin", std::ios::binary);
            f.read(reinterpret_cast<char*>(&p), sizeof p);
        }
        std::cout << p.first_name << "\n";
        std::cout << p.last_name << "\n";
    }
}

-------------------------------------------------------------------------------------

struct Person {
    char *first_name;
    char *last_name;
    /*
    std::string first_name;
    std::string last_name;
    */
};

int main() {
    Person p;
    p.first_name = "Ivan";
    p.last_name = "Ivanov";

    {
        std::ofstream f("02.bin", std::ios::binary);
        f.write(reinterpret_cast<const char*>(&p), sizeof p);
    }
    /*
        std::ofstream f("03.bin", std::ios::binary);
        f.write(reinterpret_cast<const char*>(&p), sizeof p);  // UB.
        // Потому что std::string - не POD (plain old data). Точнее: не Trivial. Точнее: не TrivialCopyable.
        // Надо что-то такое (плюс как-то указать длину, чтобы можно было прочитать):
        f.write(p.first_name.data(), p.first_name.size());
    */
}
```

## Операции со строками в стиле Си: конкатенция, получение длины, безопасная альтернатива для `gets` и `scanf("%s")`

## Массивы массивов в языке Си (вроде `int**`): выделение, освобождение, использование

