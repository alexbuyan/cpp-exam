## Синтаксис константных ссылок, применение при передаче аргументов
`Константная ссылка на объект` - удобный способ передать аргумент в функцию. Не происходит копирования, но при этом мы не разрешаем менять передаваемый объект. Поэтому вместо передачи по значению или обычной ссылке, лучше использовать const ссылку. 

Ссылка не требует ни копирований, ни перемещений, ни деструкторов

Принятие по значению вызывает либо перемещение (если был временный объект или сделали `std::move`), либо копирование + деструктор - `строго медленнее`. Это не всегда имеет смысл

`Пример когда имеет смысл` - внутри функции все равно собираемся копировать параметр. Тогда при передаче по const ссылке это всегда `копирование`, а при передаче по значению - либо `копирование + перемещение`, либо `2 копирования`

```C++
struct Foo {
    char first_symbol;

    Foo(const std::string& str) {
        assert(!str.empty());
        first_symbol = str[0];
    }
};
```

## Невозможность изменять константные объекты и их поля
Ключевое слово `const` говорит о том, что объект нельзя изменять: 
* Переменная, помеченная `const` не может меняться 
* У объект класса, помеченного `const`, можно вызывать только `const-qualifier` методы (не меняют поля класса, если они не `mutable`)

#### Про указатели
* `const X* p` - `p` указывает на константный объект. Указатель можно менять, а объект нет
* `X* const p` - `p` константный указатель. Можно менять объект, а указатель нет
* `const X* const p` - константный указатель на константный объект. Нельзя менять указатель и объект

## const-qualifier у методов (const member function), перегрузка по const-qualifier (const overloading)
При объявлении функции можно написать `const-qualifier`
```C++
const int& get_int() const
```
Тогда этот метод не будет менять поля класса. Может пригодиться, если мы работает с константным объектом и хотим вызывать у него какие-то методы. Если у метода не будет `const-qualifier`, то его нельзя будет вызвать, так как но по мнению комплилятора может менять состояни класса

### Перегрузка по `const-qualifier`
```C++
const T& operator[](size_t i) const

T& operator[](size_t i)
```
В одном случае хотим получить элемент и посмотреть на него, а в другом - поменять
