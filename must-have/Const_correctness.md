## Синтаксис константных ссылок, применение при передаче аргументов
`Константная ссылка на объект` - удобный способ передать аргумент в функцию. Не происходит копирования, но при этом мы не разрешаем менять передаваемый объект. Поэтому вместо передачи по значению или обычной ссылке, лучше использовать const ссылку (кроме случаев, когда можно вместо этого передать по значению и сделать `std::move`, что требует столько же копирования)

```C++
struct Foo {
  char first_symbol;
  
  Foo(const std::string& str) {
      assert(!str.empty());
      first_symbol = str[0];
  }
};
```

## Невозможность изменять константные объекты и их поля
Ключевое слово `const` говорит о том, что объект нельзя изменять: 
* Переменная, помеченная `const` не может меняться 
* У объект класса, помеченного `const`, можно вызывать только `const-qualifier` методы (не меняют поля класса, если они не `mutable`)

#### Про указатели
* `const X* p` - `p` указывает на константный объект. Указатель можно менять, а объект нет
* `X* const p` - `p` константный указатель. Можно менять объект, а указатель нет
* `const X* const p` - константный указатель на константный объект. Нельзя менять указатель и объект

## const-qualifier у методов (const member function), перегрузка по const-qualifier (const overloading)
При объявлении функции можно написать `const-qualifier`
```C++
const int& get_int() const
```
Тогда этот метод не будет менять поля класса. Может пригодиться, если мы работает с константным объектом и хотим вызывать у него какие-то методы. Если у метода не будет `const-qualifier`, то его нельзя будет вызвать, так как но по мнению комплилятора может менять состояни класса

### Перегрузка по `const-qualifier`
```C++
const T& operator[](size_t i) const

T& operator[](size_t i)
```
В одном случае хотим получить элемент и посмотреть на него, а в другом - поменять
